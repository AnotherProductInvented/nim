<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Nim Game: 1, 3, 5, 7</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Global Reset */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Comic Sans MS', cursive, sans-serif;
      /* Use a grassy background image if available, else fallback to a green gradient */
      background: url('grass.jpg') no-repeat center center fixed;
      background-size: cover;
      background-color: #7ec850;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      margin: 20px 0;
      font-size: 2em;
      color: #fff;
      text-shadow: 2px 2px 4px #000;
    }
    #gameContainer {
      position: relative;
      width: 500px;
      height: 500px;
      border: 2px solid #555;
      background: rgba(255,255,255,0.8);
      margin-bottom: 10px;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    button {
      font-size: 20px;
      padding: 10px 20px;
      margin: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background-color: #ffcc00;
      color: #333;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
    }
    #controls {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    #messageArea {
      font-size: 18px;
      color: #fff;
      text-shadow: 1px 1px 2px #000;
      margin: 10px;
      min-height: 24px;
    }
  </style>
</head>
<body>
  <h1>Nim Game: 1, 3, 5, 7</h1>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="500" height="500"></canvas>
  </div>
  <div id="controls">
    <button id="doneBtn">Done</button>
    <button id="newGameBtn">New Game</button>
  </div>
  <div id="messageArea"></div>

  <script>
    'use strict';
    console.log("[DEBUG] Nim Stones game started");

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const W = canvas.width;
    const H = canvas.height;

    // Stone settings
    const stoneRadius = 20;
    const stoneSpacing = 10; // horizontal spacing between stones

    // Game state: 4 rows with 1, 3, 5, and 7 stones respectively.
    let rows = [1, 3, 5, 7];
    // The active row for the human move (null if not set yet)
    let activeRow = null;
    // Whose turn: "human", "ai", or "gameover"
    let turn = "human";

    const messageArea = document.getElementById("messageArea");

    // Draw the current board
    function drawBoard() {
      ctx.clearRect(0, 0, W, H);
      const rowCount = rows.length;
      // Compute vertical spacing so rows are evenly distributed.
      const vSpacing = H / (rowCount + 1);
      for (let i = 0; i < rowCount; i++) {
        let stoneCount = rows[i];
        let y = (i + 1) * vSpacing;
        if (stoneCount > 0) {
          // Center the stones horizontally.
          let totalWidth = stoneCount * (stoneRadius * 2) + (stoneCount - 1) * stoneSpacing;
          let startX = (W - totalWidth) / 2 + stoneRadius;
          for (let j = 0; j < stoneCount; j++) {
            let x = startX + j * ((stoneRadius * 2) + stoneSpacing);
            ctx.beginPath();
            ctx.arc(x, y, stoneRadius, 0, Math.PI * 2);
            // Highlight stones in the active row if it's the humanâ€™s turn.
            ctx.fillStyle = (turn === "human" && activeRow === i) ? "#00f" : "#fff";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
        }
      }
    }

    // Utility: show temporary messages
    function showMessage(msg) {
      messageArea.textContent = msg;
      setTimeout(() => { messageArea.textContent = ""; }, 2000);
    }

    // Determine which row was clicked and remove one stone if allowed.
    canvas.addEventListener("click", function(e) {
      if (turn !== "human") return;
      const rect = canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (canvas.height / rect.height);

      const rowCount = rows.length;
      const vSpacing = H / (rowCount + 1);
      let clickedRow = null;
      // Find the row whose center is near the click.
      for (let i = 0; i < rowCount; i++) {
        let y = (i + 1) * vSpacing;
        if (Math.abs(my - y) <= stoneRadius + 10) {
          clickedRow = i;
          break;
        }
      }
      if (clickedRow === null) return;

      // If no row has been selected yet this turn, set it.
      if (activeRow === null) {
        activeRow = clickedRow;
      } else if (activeRow !== clickedRow) {
        showMessage("Remove stones from only one row per move!");
        return;
      }
      // If the selected row has stones, remove one.
      if (rows[clickedRow] <= 0) {
        showMessage("No stones left in that row!");
        return;
      }
      rows[clickedRow]--;
      drawBoard();
      if (isGameOver()) {
        showMessage("Game Over! You win!");
        turn = "gameover";
      }
    });

    // "Done" button ends the human turn and starts the AI turn.
    document.getElementById("doneBtn").addEventListener("click", function() {
      if (turn !== "human") return;
      if (activeRow === null) {
        showMessage("You must remove at least one stone.");
        return;
      }
      activeRow = null;
      turn = "ai";
      showMessage("AI's turn...");
      setTimeout(aiMove, 1000);
    });

    // "New Game" resets the board.
    document.getElementById("newGameBtn").addEventListener("click", function() {
      rows = [1, 3, 5, 7];
      activeRow = null;
      turn = "human";
      drawBoard();
      showMessage("New game started. Your turn!");
    });

    // Check if game is over (all rows are empty)
    function isGameOver() {
      return rows.every(count => count === 0);
    }

    // AI move: uses optimal Nim strategy.
    function aiMove() {
      // Compute the nim-sum.
      let nimSum = rows.reduce((acc, num) => acc ^ num, 0);
      let moveMade = false;
      if (nimSum !== 0) {
        for (let i = 0; i < rows.length; i++) {
          let target = rows[i] ^ nimSum;
          if (target < rows[i]) {
            let stonesToRemove = rows[i] - target;
            rows[i] -= stonesToRemove;
            showMessage("AI removed " + stonesToRemove + " stone(s) from row " + (i+1));
            moveMade = true;
            break;
          }
        }
      }
      if (!moveMade) {
        // If in a losing position, remove one stone from the first non-empty row.
        for (let i = 0; i < rows.length; i++) {
          if (rows[i] > 0) {
            rows[i]--;
            showMessage("AI removed 1 stone from row " + (i+1));
            moveMade = true;
            break;
          }
        }
      }
      drawBoard();
      if (isGameOver()) {
        showMessage("Game Over! AI wins!");
        turn = "gameover";
      } else {
        turn = "human";
        showMessage("Your turn!");
      }
    }

    // Initial drawing of the board.
    drawBoard();
    showMessage("Your turn! Click on a stone to remove it.");
  </script>
</body>
</html>
